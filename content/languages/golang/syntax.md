+++
title = "语法基础"
description = "golang syntax"
date = "2022-05-27"
aliases = ["golang", "go"]
author = "Hugo Authors"
+++


## 基础语法
- golang一个包内不允许有重复的函数，且即使是包分在多个文件里面也不允许出现两个同名函数和属性。
- golang函数是大小写敏感的，所以可以有
  ```go
      func getName() string{}
      func GetName() string{}
  ```
- go区分大小写，首字母大写表示public属性，首字母小写表示private属性（包外无法访问）
- 第一个{必须紧跟在括号的后面，不能新起一行
- 编译部分文件时需要把所有文件都放置于 build(run) 后面，不分先后顺序
- 在函数有多个返回值时，只要有一个返回值有命名，其他的也必须命名。如果有多个返回值必须加上括号()；如果只有一个返回值且命名也必须加上括号()
- append() 的第二个参数不能直接使用 slice，需使用 … 操作符，将一个切片追加到另一个切片上：append(s1,s2…), 或者直接跟上元素，形如：append(s1,1,2,3)
- 短变量 x := 100 使用有限制:
  1. 必须使用显示初始化；
  2. 不能提供数据类型，编译器会自动推导；
  3. 只能在 ***<font color="#A52A2A">函数内部</font>*** 使用；
- 单个字符串用单引号，多个字符串用`或者"来括起来
  - 使用 "" 包裹的字符串 会解析 字符串中的 转义符
  - 使用 `` 包裹的字符串 不会解析 字符串中的 转义符
  - 使用 "" 包裹的字符串 性能 比较慢 到 极慢（由 转义符 和 字符串的长度 决定）
  - 使用 `` 包裹的字符串 性能 极快
  - 字符串 实际上是 字符数组
  - 解析 会 遍历 整一个 字符串 (字符数组)，寻找可以 解析 的 转义符，不管 原先字符串里 有没有 转义符，都会 遍历一次
  - 不解析 则会 直接输出
- nil 只能赋值给指针、chan、func、interface、map 或 slice 类型的变量（error是内置接口类型）
- init 函数
  - init() 函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等;
  - 一个包可以出线多个 init() 函数,一个源文件也可以包含多个 init() 函数；
  - 同一个包中多个 init() 函数的执行顺序没有明确定义，但是不同包的init函数是根据包导入的依赖关系决定的（看下图）;
  - init() 函数在代码中不能被显示调用、不能被引用（赋值给函数变量），否则出现编译错误;
  - 一个包被引用多次，如 A import B,C import B,A import C，B 被引用多次，但 B 包只会初始化一次；
  - 引入包，不可出现死循坏。即 A import B,B import A，这种情况编译失败；

-------

## new和make区别
- new(T) 会为 T 类型的新值分配已置零的内存空间，并返回地址（指针），即类型为 *T 的值。换句话说就是，返回一个指针，该指针指向新分配的、类型为 T 的零值。适用于值类型，如数组、结构体等。
- make(T,args) 返回初始化之后的 T 类型的值，这个值并不是 T 类型的零值，也不是指针 *T，是经过初始化之后的 T 的引用。make() 只适用于 slice、map 和 channel

-------

## 切片和数组
- 数组是需要指定个数的，而切片则不需要。数组赋值也可是使用如下方式，忽略元素个数，使用“...”代替
- Go中的数组是值类型，换句话说，如果你将一个数组赋值给另外一个数组，那么，实际上就是将整个数组拷贝一份
- 如果Go中的数组作为函数的参数，那么实际传递的参数是一份数组的拷贝，而不是数组的指针
- array的长度也是Type的一部分，这样就说明[10]int和[20]int是不一样的
- 切片是引用类型，因此在当传递切片时将引用同一指针，修改值将会影响其他的对象
- [start:end] 是一个左闭右开区间,
- 切片可以支持第三个参数，用来限制新切片的容量，不能超过原切片的底层数组大小

--------

## 多层map赋值
类似以下这种二维结构，需要单独make子结构
```go
userBindInfo := make(map[string]map[string]interface{})
//tel is bind
userBindInfo["tel"] = make(map[string]interface{})
userBindInfo["tel"]["isbind"] = 1
userBindInfo["tel"]["name"] = "155****1234"
//wechat is bind
userBindInfo["wx"] = make(map[string]interface{})
userBindInfo["wx"]["isbind"] = 0
userBindInfo["wx"]["name"] = ""
```

## 深拷贝 浅拷贝
- 通过=操作符拷贝切片，这是浅拷贝。
- 通过[:]方式复制切片，同样是浅拷贝
- copy() 拷贝是切片深拷贝

## for range
- range 返回的是值的拷贝，而不是引用
- range 遍历 map 是无序的

## 判断某个struct是否实现了某个interface
- 判断某个结构体（即有些人称之为类）是否实现了某个接口类型
```go
var _  IFace =new(Bird)  或者 var _ IFace = (*Bird)(nil)
```
解析：这个其实就是变量定义，var  变量名  类型 = 赋值，上面中的 _ 其实就是舍去变量不要，假如实现了接口类型，编译就可以通过，没有现实编译就会出错，就是根据这个原理来实现的。
至于第二种写法与第一种的区别就是，第二种不需要分配内存就达到目的，而第一种是需要分配内存的。